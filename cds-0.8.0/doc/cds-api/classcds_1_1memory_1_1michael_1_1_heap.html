<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::memory::michael::Heap&lt; OPTIONS &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1memory.html">memory</a>      </li>
      <li><a class="el" href="namespacecds_1_1memory_1_1michael.html">michael</a>      </li>
      <li><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">Heap</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>cds::memory::michael::Heap&lt; OPTIONS &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cds::memory::michael::Heap" -->
<p>Michael's allocator.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;cds/memory/michael/allocator.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Collaboration diagram for cds::memory::michael::Heap&lt; OPTIONS &gt;:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="classcds_1_1memory_1_1michael_1_1_heap__coll__graph.png" border="0" usemap="#cds_1_1memory_1_1michael_1_1_heap_3_01_o_p_t_i_o_n_s_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="cds_1_1memory_1_1michael_1_1_heap_3_01_o_p_t_i_o_n_s_01_4_coll__map" id="cds_1_1memory_1_1michael_1_1_heap_3_01_o_p_t_i_o_n_s_01_4_coll__map">
<area shape="rect" id="node2" href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__desc.html" title="Processor descriptor." alt="" coords="5,5,376,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap_1_1active__tag.html">active_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processor heap's <code>active</code> field.  <a href="classcds_1_1memory_1_1michael_1_1_heap_1_1active__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1anchor__tag.html">anchor_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Anchor of the superblock descriptor. Updated by CAS.  <a href="structcds_1_1memory_1_1michael_1_1_heap_1_1anchor__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap_1_1block__header.html">block_header</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocated block header.  <a href="classcds_1_1memory_1_1michael_1_1_heap_1_1block__header.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__desc.html">processor_desc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processor descriptor.  <a href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__desc.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__heap__base.html">processor_heap_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processor heap.  <a href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__heap__base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1superblock__desc.html">superblock_desc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Superblock descriptor.  <a href="structcds_1_1memory_1_1michael_1_1_heap_1_1superblock__desc.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056b">superblock_state</a> { <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056ba69b7074696a8c0c92206f3eba3110ad7">SBSTATE_ACTIVE</a> =  0, 
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056bacd8ea74e654cbe54b81f28443ad7f362">SBSTATE_FULL</a> =  1, 
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056ba119c1f477c76a03de5c43994b23ed015">SBSTATE_PARTIAL</a> =  2, 
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056ba3539a7bdc73576e82e815334e10c1516">SBSTATE_EMPTY</a> =  3
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Superblock states. </p>
 <a href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056b">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7422e966b59eed1dafecded903042cc3"></a><!-- doxytag: member="cds::memory::michael::Heap::sys_topology" ref="a7422e966b59eed1dafecded903042cc3" args="" -->
typedef options::sys_topology&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a7422e966b59eed1dafecded903042cc3">sys_topology</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">effective system topology <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae4e6e2a13fafb4ab2992a658be1023"></a><!-- doxytag: member="cds::memory::michael::Heap::system_heap" ref="a7ae4e6e2a13fafb4ab2992a658be1023" args="" -->
typedef options::system_heap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a7ae4e6e2a13fafb4ab2992a658be1023">system_heap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">effective system heap <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a357cfca12d35b2ee3b161e86216f2c5e"></a><!-- doxytag: member="cds::memory::michael::Heap::aligned_heap" ref="a357cfca12d35b2ee3b161e86216f2c5e" args="" -->
typedef options::aligned_heap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a357cfca12d35b2ee3b161e86216f2c5e">aligned_heap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">effective aligned heap <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff01357d79e338d72b066a24c78b5bcb"></a><!-- doxytag: member="cds::memory::michael::Heap::sizeclass_selector" ref="aff01357d79e338d72b066a24c78b5bcb" args="" -->
typedef options::sizeclass_selector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#aff01357d79e338d72b066a24c78b5bcb">sizeclass_selector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">effective sizeclass selector <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a977a2c06bc506bd4541297eb104ba519"></a><!-- doxytag: member="cds::memory::michael::Heap::page_heap" ref="a977a2c06bc506bd4541297eb104ba519" args="" -->
typedef options::page_heap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a977a2c06bc506bd4541297eb104ba519">page_heap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">effective page heap <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac99e771bb4ddbbe4e99bac09cfd0bf47"></a><!-- doxytag: member="cds::memory::michael::Heap::procheap_stat" ref="ac99e771bb4ddbbe4e99bac09cfd0bf47" args="" -->
typedef options::procheap_stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#ac99e771bb4ddbbe4e99bac09cfd0bf47">procheap_stat</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">effective processor heap statistics <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7695976c60758a42d8910627f6a817c"></a><!-- doxytag: member="cds::memory::michael::Heap::os_allocated_stat" ref="ac7695976c60758a42d8910627f6a817c" args="" -->
typedef options::os_allocated_stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#ac7695976c60758a42d8910627f6a817c">os_allocated_stat</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">effective OS-allocated memory statistics <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b4db7b47d1a45ad39ca4b279caf7867"></a><!-- doxytag: member="cds::memory::michael::Heap::bound_checker" ref="a9b4db7b47d1a45ad39ca4b279caf7867" args="" -->
typedef <br class="typebreak"/>
details::bound_checker_selector<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
options::check_bounds &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a9b4db7b47d1a45ad39ca4b279caf7867">bound_checker</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">effective bound checker <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad503c4bc545520438b03b753579900e1"></a><!-- doxytag: member="cds::memory::michael::Heap::processor_heap" ref="ad503c4bc545520438b03b753579900e1" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="classcds_1_1details_1_1type__padding.html">cds::details::type_padding</a><br class="typebreak"/>
&lt; <a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__heap__base.html">processor_heap_base</a>, <br class="typebreak"/>
c_nAlignment &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#ad503c4bc545520438b03b753579900e1">processor_heap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned superblock descriptor. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe94273c7e4fa4d8d517c34f388223d8"></a><!-- doxytag: member="cds::memory::michael::Heap::Heap" ref="afe94273c7e4fa4d8d517c34f388223d8" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#afe94273c7e4fa4d8d517c34f388223d8">Heap</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#ac1607983eaae4ca04d3aa7a686333af0">~Heap</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> destructor.  <a href="#ac1607983eaae4ca04d3aa7a686333af0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a98886cc3a98dfe22d1e735132603b513">alloc</a> (size_t nSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory block.  <a href="#a98886cc3a98dfe22d1e735132603b513"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a265d754187440659e5c334f97fc1981f">free</a> (void *pMemory)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free previously allocated memory block.  <a href="#a265d754187440659e5c334f97fc1981f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#af3684e890a1ed150f9fb0d37390782fc">realloc</a> (void *pMemory, size_t nNewSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate memory block.  <a href="#af3684e890a1ed150f9fb0d37390782fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a28c5e5a8a0d988a785cd597efc833a10">alloc_aligned</a> (size_t nSize, size_t nAlignment)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate aligned memory block.  <a href="#a28c5e5a8a0d988a785cd597efc833a10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#ad82409f081bb8cf741dae3925e661813">free_aligned</a> (void *pMemory)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free aligned memory block previously allocated by <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a28c5e5a8a0d988a785cd597efc833a10">alloc_aligned</a>.  <a href="#ad82409f081bb8cf741dae3925e661813"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f5cd74ba0035fa9f0ef33932850644d"></a><!-- doxytag: member="cds::memory::michael::Heap::summaryStat" ref="a4f5cd74ba0035fa9f0ef33932850644d" args="(summary_stat &amp;st)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a4f5cd74ba0035fa9f0ef33932850644d">summaryStat</a> (<a class="el" href="structcds_1_1memory_1_1michael_1_1summary__stat.html">summary_stat</a> &amp;st)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get instant summary statistics. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a038d2fbefdc906a1fb83206244dd8ed4"></a><!-- doxytag: member="cds::memory::michael::Heap::c_nMaxBlockInSuperBlock" ref="a038d2fbefdc906a1fb83206244dd8ed4" args="" -->
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a038d2fbefdc906a1fb83206244dd8ed4">c_nMaxBlockInSuperBlock</a> = 1024 * 2</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max count of blocks in superblock (2 ** 11) <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af69170c9038528faa5656ffd5694bb17"></a><!-- doxytag: member="cds::memory::michael::Heap::m_Topology" ref="af69170c9038528faa5656ffd5694bb17" args="" -->
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a7422e966b59eed1dafecded903042cc3">sys_topology</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#af69170c9038528faa5656ffd5694bb17">m_Topology</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">System topology. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa55d20fde610e03da7505903351775c7"></a><!-- doxytag: member="cds::memory::michael::Heap::m_LargeHeap" ref="aa55d20fde610e03da7505903351775c7" args="" -->
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a7ae4e6e2a13fafb4ab2992a658be1023">system_heap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#aa55d20fde610e03da7505903351775c7">m_LargeHeap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> for large block. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98c885a80371c8c6b07569c9fe0f8821"></a><!-- doxytag: member="cds::memory::michael::Heap::m_AlignedHeap" ref="a98c885a80371c8c6b07569c9fe0f8821" args="" -->
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a357cfca12d35b2ee3b161e86216f2c5e">aligned_heap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a98c885a80371c8c6b07569c9fe0f8821">m_AlignedHeap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal aligned heap. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a307c71c3e628cc04a2dfa3faa1e180c4"></a><!-- doxytag: member="cds::memory::michael::Heap::m_SizeClassSelector" ref="a307c71c3e628cc04a2dfa3faa1e180c4" args="" -->
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#aff01357d79e338d72b066a24c78b5bcb">sizeclass_selector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a307c71c3e628cc04a2dfa3faa1e180c4">m_SizeClassSelector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Size-class selector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca4a902350ab92a748015e9e5ff5e1f4"></a><!-- doxytag: member="cds::memory::michael::Heap::m_arrProcDesc" ref="aca4a902350ab92a748015e9e5ff5e1f4" args="" -->
<a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__desc.html">processor_desc</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#aca4a902350ab92a748015e9e5ff5e1f4">m_arrProcDesc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">array of pointers to the processor descriptors <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53dd1be00209087b6fd58bd4df428fe5"></a><!-- doxytag: member="cds::memory::michael::Heap::m_nProcessorCount" ref="a53dd1be00209087b6fd58bd4df428fe5" args="" -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a53dd1be00209087b6fd58bd4df428fe5">m_nProcessorCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processor count. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af21b211a608eff7d9bc614ab6ed45b2d"></a><!-- doxytag: member="cds::memory::michael::Heap::m_BoundChecker" ref="af21b211a608eff7d9bc614ab6ed45b2d" args="" -->
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a9b4db7b47d1a45ad39ca4b279caf7867">bound_checker</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#af21b211a608eff7d9bc614ab6ed45b2d">m_BoundChecker</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound checker. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09f975a5f9bf64f8320b7061509ca2c4"></a><!-- doxytag: member="cds::memory::michael::Heap::m_OSAllocStat" ref="a09f975a5f9bf64f8320b7061509ca2c4" args="" -->
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#ac7695976c60758a42d8910627f6a817c">os_allocated_stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a09f975a5f9bf64f8320b7061509ca2c4">m_OSAllocStat</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">OS-allocated memory statistics. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename... OPTIONS&gt;<br/>
 class cds::memory::michael::Heap&lt; OPTIONS &gt;</h3>

<p>Michael's allocator. </p>
<p>This class provides base functionality for Michael's allocator. It does not provide the interface described by <code>std::allocator</code>, therefore, we name it as a heap, not as an allocator. The heap interface is closer to semantics of <code>malloc</code> / <code>free</code> system functions. The heap supports allocation of aligned and unaligned data.</p>
<p>The algorithm is based on simplified version of </p>
<ul>
<li>[2004] M.Michael "Scalable Lock-free Dynamic Memory Allocation"</li>
</ul>
<p>that, in turn, is concurrent version of well-known Hoard allocator developed by Emery Berger, see </p>
<ul>
<li>[2002] Emery Berger "Memory Management for High-Performance Application", PhD thesis</li>
</ul>
<p>This is powerful, scalable, fully customizable heap with fast-path without any locks that has been developed specifically for multi-threading. With opt:topology you can set as many allocation arena ("processor heap") as you need. You can manually bound any your thread to any arena ("processor"). With <a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1sizeclass__selector.html" title="Option setter specifies size-class selector.">opt::sizeclass_selector</a> option you can manage allocation granularity. With <a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1page__heap.html" title="Option setter specifies page heap.">opt::page_heap</a> you can utilize any OS-provided features for page allocation like <code>mmap</code>, <code>VirtualAlloc</code> etc. The heap can gather internal statistics that helps you to tune your application. The <a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1check__bounds.html" title="Option setter for bounds checking.">opt::check_bounds</a> feature can help you to find a memory buffer overflow.</p>
<p>Brief algorithm description from Michael's work:</p>
<p>Large blocks (greater than 64K) are allocated directly from the <a class="el" href="namespacecds_1_1_o_s.html" title="OS specific wrappers.">OS</a> and freed directly to the <a class="el" href="namespacecds_1_1_o_s.html" title="OS specific wrappers.">OS</a>. For smaller block sizes, the heap is composed of large superblocks (64 KB or 1MB size). Each superblock is divided into multiple equal-sized blocks. Superblocks are distributed among size classes based on their block sizes. Each size class contains multiple processor heaps proportional to the number of processors in the system. A processor heap contains at most one active superblock. An active superblock contains one or more blocks available for reservation that are guaranteed to be available to threads that reach them through the header of the processor heap. Each superblock is associated with a descriptor. Each allocated block contains a prefix (8 bytes) that points to the descriptor of its superblock. On the first call to malloc, the static structures for the size classes and processor heaps (about 16 KB for a 16 processor machine) are allocated and initialized in a lock-free manner.</p>
<p>Malloc starts by identifying the appropriate processor heap, based on the requested block size and the identity of the calling thread. Typically, the heap already has an active superblock with blocks available for reservation. The thread atomically reads a pointer to the descriptor of the active superblock and reserves a block. Next, the thread atomically pops a block from that superblock and updates its descriptor. A typical free pushes the freed block into the list of available blocks of its original superblock by atomically updating its descriptor.</p>
<p><b>Constraint</b>: one superblock may contain up to 2048 block. This restriction imposes a restriction on the maximum superblock size.</p>
<p>Available <code>OPTIONS:</code> </p>
<ul>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1sys__topology.html">opt::sys_topology</a> - class that describes system topology needed for allocator. Default is <code>cds::OS::topology</code> (see <a class="el" href="structcds_1_1_o_s_1_1_win32_1_1topology.html" title="System topology.">cds::OS::Win32::topology</a> for interface description)</li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1system__heap.html">opt::system_heap</a> - option setter for an allocator for large blocks that is used for direct allocation from <a class="el" href="namespacecds_1_1_o_s.html" title="OS specific wrappers.">OS</a>. Default is <a class="el" href="structcds_1_1memory_1_1michael_1_1malloc__heap.html">malloc_heap</a>.</li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1aligned__heap.html">opt::aligned_heap</a> - option setter for a heap used for internal aligned memory management. Default is <a class="el" href="structcds_1_1memory_1_1michael_1_1aligned__malloc__heap.html">aligned_malloc_heap</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1page__heap.html">opt::page_heap</a> - option setter for a heap used for page (superblock) allocation of 64K/1M size. Default is <a class="el" href="classcds_1_1memory_1_1michael_1_1page__cached__allocator.html">page_cached_allocator</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1sizeclass__selector.html">opt::sizeclass_selector</a> - option setter for a class used to select appropriate size-class for incoming allocation request. Default is <a class="el" href="classcds_1_1memory_1_1michael_1_1default__sizeclass__selector.html">default_sizeclass_selector</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1free__list.html">opt::free_list</a> - option setter for a class to manage a list of free superblock descriptors Default is <a class="el" href="classcds_1_1memory_1_1michael_1_1free__list__locked.html">free_list_locked</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1partial__list.html">opt::partial_list</a> - option setter for a class to manage a list of partial filled superblocks Default is <a class="el" href="classcds_1_1memory_1_1michael_1_1partial__list__locked.html">partial_list_locked</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1procheap__stat.html">opt::procheap_stat</a> - option setter for a class to gather internal statistics for memory allocation that is maintained by the heap. Default is <a class="el" href="classcds_1_1memory_1_1michael_1_1procheap__empty__stat.html">procheap_empty_stat</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1os__allocated__stat.html">opt::os_allocated_stat</a> - option setter for a class to gather internal statistics for large block allocation. Term "large block" is specified by the size-class selector (see <a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1sizeclass__selector.html">opt::sizeclass_selector</a>) and it is 64K for <a class="el" href="classcds_1_1memory_1_1michael_1_1default__sizeclass__selector.html">default_sizeclass_selector</a>. Any block that is large that 64K is allocated from <a class="el" href="namespacecds_1_1_o_s.html" title="OS specific wrappers.">OS</a> directly. <code>os_allocated_stat</code> option is set a class to gather statistics for large blocks. Default is <a class="el" href="structcds_1_1memory_1_1michael_1_1os__allocated__empty.html">os_allocated_empty</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1check__bounds.html">opt::check_bounds</a> - a bound checker. Default is no bound checker (<a class="el" href="structcds_1_1opt_1_1none.html" title="Type indicates that no option is being used and that the default options should be used...">cds::opt::none</a>)</li>
</ul>
<dl class="user"><dt><b>Usage:</b></dt><dd>The heap is the basic building block for your allocator or <code> operator new</code> implementation.</dd></dl>
<div class="fragment"><pre class="fragment"><span class="preprocessor">        #include &lt;cds/memory/michael/allocator.h&gt;</span>

        <span class="comment">// Heap with explicitly defined options:</span>
        <a class="code" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&amp;#39;s allocator.">cds::memory::michael::Heap</a>&lt; 
            opt::aligned_heap&lt; aligned_malloc_heap &gt;,
            opt::page_heap&lt; page_cached_allocator&lt;16, malloc_heap&gt; &gt;
        &gt;   myHeap  ;

        <span class="comment">// Heap with default options:</span>
        <a class="code" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&amp;#39;s allocator.">cds::memory::michael::Heap&lt;&gt;</a>    myDefHeap   ;
</pre></div><dl class="user"><dt><b>How to make std-like allocator</b></dt><dd></dd></dl>
<p>There are serious differencies of heap and <code>std::allocator</code> interface:</p>
<ul>
<li><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> is stateful, and <code>std::allocator</code> is stateless.</li>
<li><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> has much more template parameters than <code>std::allocator</code> </li>
<li><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> has low-level interface for memory allocating only unlike the allocator interface that can construct/destroy objects of any type T.</li>
</ul>
<p>To convert heap interface into <code>std::allocator</code> -like interface you should:</p>
<ul>
<li>Declare object of class <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">cds::memory::michael::Heap</a> specifying the necessary template parameters; this is usually static object</li>
<li>Create a class with <code>std::allocator</code> interface that uses the function of heap. <div class="fragment"><pre class="fragment"><span class="preprocessor">        #include &lt;cds/memory/michael/allocator.h&gt;</span>

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
        <span class="keyword">class </span>MichaelAllocator 
        {
            <span class="keyword">typedef</span> std::allocator&lt;T&gt;               std_allocator   ;
            <span class="keyword">typedef</span> <a class="code" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&amp;#39;s allocator.">cds::memory::michael::Heap&lt;&gt;</a>    michael_heap    ;

            <span class="comment">// Michael heap static object</span>
            <span class="keyword">static</span> michael_heap     s_Heap  ;
        <span class="keyword">public</span>:
            <span class="comment">// Declare typedefs from std::allocator</span>
            <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::const_pointer   const_pointer   ;
            <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::pointer         pointer         ;
            <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::const_reference const_reference ;
            <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::reference       reference       ;
            <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::difference_type difference_type ;
            <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::size_type       size_type       ;
            <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::value_type      value_type      ;

            <span class="comment">// Allocation function</span>
            pointer allocate( size_type _Count, <span class="keyword">const</span> <span class="keywordtype">void</span>* _Hint )
            {
                <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>( s_Heap.alloc( <span class="keyword">sizeof</span>(T) * _Count )) ;
            }

            <span class="comment">// Deallocation function</span>
            <span class="keywordtype">void</span> deallocate( pointer _Ptr, size_type _Count )
            {
                s_Heap.<a class="code" href="classcds_1_1memory_1_1michael_1_1_heap.html#a265d754187440659e5c334f97fc1981f" title="Free previously allocated memory block.">free</a>( _Ptr ) ;
            }

            <span class="comment">// Other std::allocator specific functions: address, construct, destroy, etc.</span>
            ...

            <span class="comment">// Rebinding allocator to other type</span>
            <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Other&gt;
            <span class="keyword">struct </span>rebind {
                <span class="keyword">typedef</span> MichaelAllocator&lt;_Other&gt; <a class="code" href="class_a_l_l_o_c_a_t_o_r_1_1template_01rebind_1_1other.html">other</a>;
            };
        };

        <span class="comment">// In .cpp file:</span>
        MichaelAllocator::michael_heap MichaelAllocator::s_Heap ;
</pre></div> </li>
</ul>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a6a0beaa35451ba2bad793c48bdaa056b"></a><!-- doxytag: member="cds::memory::michael::Heap::superblock_state" ref="a6a0beaa35451ba2bad793c48bdaa056b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OPTIONS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056b">cds::memory::michael::Heap::superblock_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Superblock states. </p>
<p>A superblock can be in one of four states: <code>ACTIVE</code>, <code>FULL</code>, <code>PARTIAL</code>, or <code>EMPTY</code>. A superblock is <code>ACTIVE</code> if it is the active superblock in a heap, or if a thread intends to try to install it as such. A superblock is <code>FULL</code> if all its blocks are either allocated or reserved. A superblock is <code>PARTIAL</code> if it is not <code>ACTIVE</code> and contains unreserved available blocks. A superblock is <code>EMPTY</code> if all its blocks are free and it is not <code>ACTIVE</code>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a6a0beaa35451ba2bad793c48bdaa056ba69b7074696a8c0c92206f3eba3110ad7"></a><!-- doxytag: member="SBSTATE_ACTIVE" ref="a6a0beaa35451ba2bad793c48bdaa056ba69b7074696a8c0c92206f3eba3110ad7" args="" -->SBSTATE_ACTIVE</em>&nbsp;</td><td>
<p>superblock is active </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6a0beaa35451ba2bad793c48bdaa056bacd8ea74e654cbe54b81f28443ad7f362"></a><!-- doxytag: member="SBSTATE_FULL" ref="a6a0beaa35451ba2bad793c48bdaa056bacd8ea74e654cbe54b81f28443ad7f362" args="" -->SBSTATE_FULL</em>&nbsp;</td><td>
<p>superblock is full </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6a0beaa35451ba2bad793c48bdaa056ba119c1f477c76a03de5c43994b23ed015"></a><!-- doxytag: member="SBSTATE_PARTIAL" ref="a6a0beaa35451ba2bad793c48bdaa056ba119c1f477c76a03de5c43994b23ed015" args="" -->SBSTATE_PARTIAL</em>&nbsp;</td><td>
<p>superblock is partially allocated </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6a0beaa35451ba2bad793c48bdaa056ba3539a7bdc73576e82e815334e10c1516"></a><!-- doxytag: member="SBSTATE_EMPTY" ref="a6a0beaa35451ba2bad793c48bdaa056ba3539a7bdc73576e82e815334e10c1516" args="" -->SBSTATE_EMPTY</em>&nbsp;</td><td>
<p>superblock is empty and may be freed </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac1607983eaae4ca04d3aa7a686333af0"></a><!-- doxytag: member="cds::memory::michael::Heap::~Heap" ref="ac1607983eaae4ca04d3aa7a686333af0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OPTIONS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; OPTIONS &gt;::~<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">Heap</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> destructor. </p>
<p>The destructor frees all memory allocated by the heap. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a98886cc3a98dfe22d1e735132603b513"></a><!-- doxytag: member="cds::memory::michael::Heap::alloc" ref="a98886cc3a98dfe22d1e735132603b513" args="(size_t nSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OPTIONS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; OPTIONS &gt;::alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nSize</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate memory block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nSize</td><td>Size of memory block to allocate in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28c5e5a8a0d988a785cd597efc833a10"></a><!-- doxytag: member="cds::memory::michael::Heap::alloc_aligned" ref="a28c5e5a8a0d988a785cd597efc833a10" args="(size_t nSize, size_t nAlignment)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OPTIONS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; OPTIONS &gt;::alloc_aligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nAlignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate aligned memory block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nSize</td><td>Size of memory block to allocate in bytes </td></tr>
    <tr><td class="paramname">nAlignment</td><td>Alignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a265d754187440659e5c334f97fc1981f"></a><!-- doxytag: member="cds::memory::michael::Heap::free" ref="a265d754187440659e5c334f97fc1981f" args="(void *pMemory)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OPTIONS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; OPTIONS &gt;::free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>pMemory</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free previously allocated memory block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pMemory</td><td>Pointer to memory block to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad82409f081bb8cf741dae3925e661813"></a><!-- doxytag: member="cds::memory::michael::Heap::free_aligned" ref="ad82409f081bb8cf741dae3925e661813" args="(void *pMemory)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OPTIONS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; OPTIONS &gt;::free_aligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>pMemory</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free aligned memory block previously allocated by <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a28c5e5a8a0d988a785cd597efc833a10">alloc_aligned</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pMemory</td><td>Pointer to memory block to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3684e890a1ed150f9fb0d37390782fc"></a><!-- doxytag: member="cds::memory::michael::Heap::realloc" ref="af3684e890a1ed150f9fb0d37390782fc" args="(void *pMemory, size_t nNewSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OPTIONS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; OPTIONS &gt;::realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>pMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nNewSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reallocate memory block. </p>
<p>If <code>nNewSize</code> is zero, then the block pointed to by <code>pMemory</code> is freed; the return value is <code>NULL</code>, and <code>pMemory</code> is left pointing at a freed block.</p>
<p>If there is not enough available memory to expand the block to the given size, the original block is left unchanged, and <code>NULL</code> is returned.</p>
<p>Aligned memory block cannot be realloc'ed: if <code>pMemory</code> has been allocated by <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a28c5e5a8a0d988a785cd597efc833a10">alloc_aligned</a>, then the return value is <code>NULL</code> and the original block is left unchanged. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pMemory</td><td>Pointer to previously allocated memory block </td></tr>
    <tr><td class="paramname">nNewSize</td><td>New size of memory block, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/memory/michael/allocator.h</li>
</ul>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.8.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2011
			<br/>
			<i>Autogenerated Mon Mar 28 2011 21:10:40 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>
