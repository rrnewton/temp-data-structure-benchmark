<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: Ordered list common interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="main.html">CDS: Concurrent Data Structures library</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Ordered list common interface </h1>  </div>
</div>
<div class="contents">
<p>The implementations of ordered list are divided into two group. The first group is GC-based list that supports item erasing. We calls that list as deletable list. The second group is based on <a class="el" href="structcds_1_1gc_1_1no__gc.html" title="Tag for empty GC schema for lock-free objects without deletion of items (persistent data structure)...">cds::gc::no_gc</a> that means the list is persistent and it does not support item erasing. The interface for persistent and deletable list is slightly different.</p>
<p>Preconditions for template parameters: </p>
<ul>
<li><code>VALUE</code> should be default-constructible</li>
</ul>
<p>Any ordered list implementation in CDS library supports the following interface:</p>
<dl class="user"><dt><b>Stable interface</b></dt><dd></dd></dl>
<h2><a class="anchor" id="insert"></a>
insert</h2>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> insert (<span class="keyword">const</span> KEY &amp;key, <span class="keyword">const</span> VALUE &amp;val)
</pre></div><p> Insert new item (<em>key</em>, <em>val</em>) into the list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key </td></tr>
    <tr><td class="paramname">val</td><td>a value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if insertion succeeded, <code>false</code> otherwise (i.e. the <em>key</em> already in the list)</dd></dl>
<h2><a class="anchor" id="insert"></a>
insert</h2>
<div class="fragment"><pre class="fragment">    VALUE * insert (<span class="keyword">const</span> KEY &amp;key)
</pre></div><p> [Persistent list only] Inserts new item with <em>key</em> into the list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the value of new item. If the key already exists in the list returns NULL.</dd></dl>
<p>Recall that persistent list has concurrent nature. The pointer returned points to the value of list's item that may be changed concurrently by other thread. You should use some proper synchronization on per-value basis or atomic operations when value changing.</p>
<h2><a class="anchor" id="insert"></a>
insert</h2>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> FUNC&gt;
    <span class="keywordtype">bool</span> insert (<span class="keyword">const</span> KEY &amp;key, <span class="keyword">const</span> T &amp;val, FUNC func )
</pre></div><p> Insert new item (<em>key</em>, <em>val</em>) into the map </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is a key </td></tr>
    <tr><td class="paramname">val</td><td>is a value </td></tr>
    <tr><td class="paramname">func</td><td>is uset-defined functor to initialize new item's value.</td></tr>
  </table>
  </dd>
</dl>
<p>The signature of functor <code>func</code> is: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>insert_functor {
        <span class="keywordtype">void</span> operator()( VALUE&amp; itemValue, <span class="keyword">const</span> T&amp; val ) ;
    };
</pre></div><p> where </p>
<ul>
<li><code>itemValue</code> is value of item inserted </li>
<li><code>val</code> is the value passed to <code>insert</code> member function The functor <code>func</code> must guarantee that during changing the value <code>itemValue</code> no other changes or reads could be made on this map item by concurrent threads.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if insertion succeeded, <code>false</code> otherwise (i.e. the <em>key</em> already in the map)</dd></dl>
<h2><a class="anchor" id="ensure"></a>
ensure</h2>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> FUNC&gt;
    std::pair&lt; bool, bool &gt; ensure (<span class="keyword">const</span> KEY &amp;key, <span class="keyword">const</span> T &amp;val, FUNC func)
</pre></div><p> Ensures that key <em>key</em> exists in list, changes data of existing item to <em>val</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key to find </td></tr>
    <tr><td class="paramname">val</td><td>a value </td></tr>
    <tr><td class="paramname">func</td><td>the functor making change of item's value</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If <code>key</code> exists in the list then changes the value of the item pointed by <code>key</code> to <code>val</code>. Changing is performed by calling user-defined function <code>func</code> with signature: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> func( VALUE&amp; itemValue, <span class="keyword">const</span> VALUE&amp; val, <span class="keywordtype">bool</span> bNew ) ;
</pre></div><p> where parameters are: </p>
<ul>
<li><code>itemValue</code> is the reference to the map's item pointed by key <code>key</code> </li>
<li><code>val</code> is the value passed to <code>ensure</code> member function </li>
<li><code>bNew</code> equals <code>true</code> if a new item has been added for <code>key</code>, and <code>false</code> if <code>key</code> is found.</li>
</ul>
<p>User-defined functor <code>func</code> must guarantee that during changing key's value no any other changes or reads could be made on this list item by concurrent threads.</p>
<p>If <code>key</code> is not in list then add it. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>std::pair&lt;bool, bool&gt;</code> where <code>first</code> is <code>true</code> if operation is successfull, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with <em>key</em> already in list.</dd></dl>
<h2><a class="anchor" id="emplace"></a>
emplace</h2>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> FUNC&gt;
    <span class="keywordtype">bool</span> emplace( <span class="keyword">const</span> KEY&amp; key, <span class="keyword">const</span> T&amp; val, FUNC func )
</pre></div><p> Emplaces the vale of key <code>key</code> with new value <code>val</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key to find </td></tr>
    <tr><td class="paramname">val</td><td>new value </td></tr>
    <tr><td class="paramname">func</td><td>function to change the value of key <code>key</code> </td></tr>
  </table>
  </dd>
</dl>
<p>The operation changes the value (or a part of the value) of key <code>key</code> to new one <code>val</code>. The user-defined functor <code>func</code> has the purpose like <code>func</code> argument of <a class="el" href="ordered_list_common_interface.html#ensure">ensure</a> member function. The signature of <code>func</code> is </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">void</span> func( VALUE&amp; itemValue, <span class="keyword">const</span> T&amp; val ) ;
</pre></div><p> The first argument <code>itemValue</code> of user-defined function <code>func</code> is the reference to the list's item pointed by key <code>key</code>. The second argument <code>val</code> is the value passed to <code>emplace</code> member function. User-defined function <code>func</code> must guarantee that during changing key's value no any other changes could be made on this list's item by a concurrent thread. The list guarantees only that the item found by key cannot be deleted while <code>func</code> works</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns <code>true</code> if the key <code>key</code> exists in the list, <code>false</code> otherwise</dd></dl>
<h2><a class="anchor" id="erase"></a>
erase</h2>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> erase (<span class="keyword">const</span> KEY &amp;key)
</pre></div><p> [Deletable list only] Erase a key <em>key</em> from the list </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key for deleting </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if key <em>key</em> is found and deleted from the list, <code>false</code> if the <em>key</em> is not found in the list </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The <code>erase</code> method is applicable for non-persistent implementation only</dd></dl>
<h2><a class="anchor" id="find"></a>
find</h2>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> find (<span class="keyword">const</span> KEY &amp;key)
</pre></div><p> Find a key <code>key</code> in the list </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key finding for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>key</em> found, <code>false</code> otherwise</dd></dl>
<h2><a class="anchor" id="find"></a>
find</h2>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> FUNC&gt;
    <span class="keywordtype">bool</span> find (<span class="keyword">const</span> KEY &amp;key, T &amp;data, FUNC func)
</pre></div><p> Find key in the list. If key is found returns its data in <em>data</em> parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key </td></tr>
    <tr><td class="paramname">val</td><td>a value found </td></tr>
    <tr><td class="paramname">func</td><td>the user-defined function to copy item's value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>key</em> found, <code>false</code> otherwise</dd></dl>
<p>If <code>key</code> found the function calls user-defined function <code>func</code> with parameters: </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">void</span> func( T&amp; data, <span class="keyword">const</span> VALUE&amp; itemValue )
</pre></div><p> where <code>itemValue</code> is the item found by <code>key</code>. The user-defined function copies the item's value <code>itemValue</code> or its part to <code>data</code>. The list guarantees only that the item found cannot be deleted while <code>func</code> call. The user-defined function <code>func</code> should take into account that concurrent threads may change the item value and performs some synchronization during copying.</p>
<h2><a class="anchor" id="get"></a>
get</h2>
<div class="fragment"><pre class="fragment">    VALUE * <span class="keyword">get</span>( <span class="keyword">const</span> KEY&amp; key )
</pre></div><p> [Persistent list only] Find key in the list </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the value found. If the key is not found returns NULL.</dd></dl>
<p>Remember, that other thread may change item's value concurrently. You should use some proper synchronization or atomic operations on per-value basis when value changing.</p>
<h2><a class="anchor" id="empty"></a>
empty</h2>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> empty () const
</pre></div><p> Check if the list is empty. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the list is empty, <code>false</code> otherwise</dd></dl>
<h2><a class="anchor" id="clear"></a>
clear</h2>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> clear ()
</pre></div><p> Clears the list. For many list implementation (and for all of persistent list) this function is not thread safe. </p>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.8.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2011
			<br/>
			<i>Autogenerated Mon Mar 28 2011 21:10:36 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>
