<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::gc::hzp::GarbageCollector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc.html">gc</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc_1_1hzp.html">hzp</a>      </li>
      <li><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<h1>cds::gc::hzp::GarbageCollector Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cds::gc::hzp::GarbageCollector" -->
<p>Hazard Pointer singleton.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;cds/gc/hzp/hzp.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Collaboration diagram for cds::gc::hzp::GarbageCollector:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="classcds_1_1gc_1_1hzp_1_1_garbage_collector__coll__graph.png" border="0" usemap="#cds_1_1gc_1_1hzp_1_1_garbage_collector_coll__map" alt="Collaboration graph"/></div>
<map name="cds_1_1gc_1_1hzp_1_1_garbage_collector_coll__map" id="cds_1_1gc_1_1hzp_1_1_garbage_collector_coll__map">
<area shape="rect" id="node2" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html" title="Internal list of cds::gc::hzp::details::HPRec." alt="" coords="825,109,1100,139"/><area shape="rect" id="node12" href="classcds_1_1atomic.html" title="cds::atomic\&lt; hplist_node * \&gt;" alt="" coords="1233,109,1423,139"/><area shape="rect" id="node4" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html" title="Hazard pointer record of the thread." alt="" coords="428,32,617,61"/><area shape="rect" id="node6" href="classcds_1_1gc_1_1hzp_1_1details_1_1retired__vector.html" title="Array of retired pointers." alt="" coords="43,5,267,35"/><area shape="rect" id="node8" href="classcds_1_1gc_1_1hzp_1_1details_1_1_h_p_allocator.html" title="cds::gc::hzp::details::HPAllocator\&lt; HazardPtr \&gt;" alt="" coords="5,59,304,88"/><area shape="rect" id="node10" href="classcds_1_1atomic.html" title="cds::atomic\&lt; bool \&gt;" alt="" coords="453,85,592,115"/><area shape="rect" id="node15" href="classcds_1_1atomic.html" title="cds::atomic\&lt; OS::ThreadId \&gt;" alt="" coords="428,139,617,168"/><area shape="rect" id="node19" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_statistics.html" title="Internal GC statistics." alt="" coords="831,308,1095,337"/><area shape="rect" id="node21" href="classcds_1_1atomics_1_1event__counter.html" title="Atomic event counter." alt="" coords="431,320,615,349"/><area shape="rect" id="node23" href="classcds_1_1atomic.html" title="cds::atomic\&lt; size_t \&gt;" alt="" coords="80,320,229,349"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal list of <a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html" title="Hazard pointer record of the thread.">cds::gc::hzp::details::HPRec</a>.  <a href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html">InternalState</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal GC statistics.  <a href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_statistics.html">Statistics</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal GC statistics.  <a href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_statistics.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b8ab2884857010aeaf192b0e83523b"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::CDS_DECLARE_EXCEPTION" ref="a77b8ab2884857010aeaf192b0e83523b" args="(HZPManagerEmpty,&quot;Global Hazard Pointer GarbageCollector is NULL&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a77b8ab2884857010aeaf192b0e83523b">CDS_DECLARE_EXCEPTION</a> (HZPManagerEmpty,&quot;Global Hazard Pointer <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a> is NULL&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">No <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> object is created. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10cf87cc78b7c3a5cea1d6ef208f4f93"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::CDS_DECLARE_EXCEPTION" ref="a10cf87cc78b7c3a5cea1d6ef208f4f93" args="(HZPTooMany,&quot;Not enough required Hazard Pointer count&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a10cf87cc78b7c3a5cea1d6ef208f4f93">CDS_DECLARE_EXCEPTION</a> (HZPTooMany,&quot;Not enough required Hazard Pointer count&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Not enough required Hazard Pointer count. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8533c264f525949b4fdd3acd07585483"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::getHazardPointerCount" ref="a8533c264f525949b4fdd3acd07585483" args="() const " -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a8533c264f525949b4fdd3acd07585483">getHazardPointerCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max Hazard Pointer count defined in construction time. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac880856b93166953a26f8c764b668e3c"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::getMaxThreadCount" ref="ac880856b93166953a26f8c764b668e3c" args="() const " -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ac880856b93166953a26f8c764b668e3c">getMaxThreadCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max thread count defined in construction time. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa640f5cd380437f7ee649be15bcd4b23"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::getMaxRetiredPtrCount" ref="aa640f5cd380437f7ee649be15bcd4b23" args="() const " -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#aa640f5cd380437f7ee649be15bcd4b23">getMaxRetiredPtrCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max size of retired objects array. It is defined in construction time. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad985a9c7cd12f3ab2f2fa4fcae254d7f"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::getInternalState" ref="ad985a9c7cd12f3ab2f2fa4fcae254d7f" args="(InternalState &amp;stat) const " -->
<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html">InternalState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad985a9c7cd12f3ab2f2fa4fcae254d7f">getInternalState</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html">InternalState</a> &amp;stat) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get internal statistics. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae138f31cf537368b05a89622d73a0f81"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::isStatisticsEnabled" ref="ae138f31cf537368b05a89622d73a0f81" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ae138f31cf537368b05a89622d73a0f81">isStatisticsEnabled</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if internal statistics enabled. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47b1c5520a9637e0420301020ddb3227"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::enableStatistics" ref="a47b1c5520a9637e0420301020ddb3227" args="(bool bEnable)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a47b1c5520a9637e0420301020ddb3227">enableStatistics</a> (bool bEnable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables internal statistics. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3d69104b13a2f6a3f9e9be8042127eb"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::getScanType" ref="ac3d69104b13a2f6a3f9e9be8042127eb" args="() const " -->
<a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ac3d69104b13a2f6a3f9e9be8042127eb">getScanType</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current scan strategy. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ab0321a557cbd6a787bb5134d805da33b">setScanType</a> (<a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> nScanType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current scan strategy.  <a href="#ab0321a557cbd6a787bb5134d805da33b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08b7b53870d9aabefcd7cb28e7997aeb"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::AllocateHPRec" ref="a08b7b53870d9aabefcd7cb28e7997aeb" args="()" -->
<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a08b7b53870d9aabefcd7cb28e7997aeb">AllocateHPRec</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates Hazard Pointer GC record. For internal use only. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae4a95cca765fdb510fb59b4466360e8"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::RetireHPRec" ref="aae4a95cca765fdb510fb59b4466360e8" args="(details::HPRec *pRec)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#aae4a95cca765fdb510fb59b4466360e8">RetireHPRec</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pRec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free HP record. For internal use only. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a01bb09f35b1062c4decffce171c5620d">Scan</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pRec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The main garbage collecting function.  <a href="#a01bb09f35b1062c4decffce171c5620d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a9e7056afcbc33c6cea9b32799f2e02d0">HelpScan</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pThis)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper scan routine.  <a href="#a9e7056afcbc33c6cea9b32799f2e02d0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void CDS_STDCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a661b77fe748dc4c680fe7d93a10b8dae">Construct</a> (size_t nHazardPtrCount=0, size_t nMaxThreadCount=0, size_t nMaxRetiredPtrCount=0, <a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> nScanType=inplace)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> singleton.  <a href="#a661b77fe748dc4c680fe7d93a10b8dae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void CDS_STDCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ac79c36f81454eb6002678dd3777b0a76">Destruct</a> (bool bDetachAll=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys global instance of <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a>.  <a href="#ac79c36f81454eb6002678dd3777b0a76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3c1621f0149d267180733f03e06c0bc"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::instance" ref="ab3c1621f0149d267180733f03e06c0bc" args="()" -->
static <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ab3c1621f0149d267180733f03e06c0bc">instance</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade090e19517a5f78ec962a34293f67b2"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::isUsed" ref="ade090e19517a5f78ec962a34293f67b2" args="()" -->
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ade090e19517a5f78ec962a34293f67b2">isUsed</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if global GC object is constructed and may be used. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#aca8ba27f700ea8628550f0087a6394eb">checkHPCount</a> (unsigned int nRequiredCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that required hazard pointer count <code>nRequiredCount</code> is less or equal then max hazard pointer count.  <a href="#aca8ba27f700ea8628550f0087a6394eb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad270c41d49a492134c6029a0733f567c">classic_scan</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pRec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Classic scan algorithm.  <a href="#ad270c41d49a492134c6029a0733f567c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#adf7f45ee415a27a24f72433d4b33adfc">inplace_scan</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pRec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place scan algorithm.  <a href="#adf7f45ee415a27a24f72433d4b33adfc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a31dda8e3842b9d9fe0e6188311c6ff03">GarbageCollector</a> (size_t nHazardPtrCount=0, size_t nMaxThreadCount=0, size_t nMaxRetiredPtrCount=0, <a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> nScanType=inplace)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor.  <a href="#a31dda8e3842b9d9fe0e6188311c6ff03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac72af2c1c3de4dc0cbef2623624e63f9"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::~GarbageCollector" ref="ac72af2c1c3de4dc0cbef2623624e63f9" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ac72af2c1c3de4dc0cbef2623624e63f9">~GarbageCollector</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dtor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae54bab023394c169aab592cf20e59077"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::NewHPRec" ref="ae54bab023394c169aab592cf20e59077" args="()" -->
<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ae54bab023394c169aab592cf20e59077">NewHPRec</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate new HP record. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a473247d2dcbe379c9c7e7a92b0dfec8a">DeleteHPRec</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> *pNode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently deletes HPrecord <code>pNode</code>.  <a href="#a473247d2dcbe379c9c7e7a92b0dfec8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#adbb722267c82e7bc69196d0346b3ad70">DeletePtr</a> (<a class="el" href="structcds_1_1gc_1_1details_1_1retired__ptr.html">details::retired_ptr</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently deletes retired pointer <code>p</code>.  <a href="#adbb722267c82e7bc69196d0346b3ad70"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0e5d9ba7f343e57d063a240fd0f8638"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_pListHead" ref="af0e5d9ba7f343e57d063a240fd0f8638" args="" -->
<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#af0e5d9ba7f343e57d063a240fd0f8638">m_pListHead</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Head of GC list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a820c23aadfcafce89a3f8c9f0c95ab65"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_Stat" ref="a820c23aadfcafce89a3f8c9f0c95ab65" args="" -->
<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_statistics.html">Statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a820c23aadfcafce89a3f8c9f0c95ab65">m_Stat</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3001475b9ab9ff7789e33b241a8ea2b9"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_bStatEnabled" ref="a3001475b9ab9ff7789e33b241a8ea2b9" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a3001475b9ab9ff7789e33b241a8ea2b9">m_bStatEnabled</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">true - statistics enabled <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08750cabd8d3dabdb3d82a464c924f1a"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_nHazardPointerCount" ref="a08750cabd8d3dabdb3d82a464c924f1a" args="" -->
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a08750cabd8d3dabdb3d82a464c924f1a">m_nHazardPointerCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">max count of thread's hazard pointer <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a824fff7e9b1d7cfcfaa60b7d1d1853d1"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_nMaxThreadCount" ref="a824fff7e9b1d7cfcfaa60b7d1d1853d1" args="" -->
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a824fff7e9b1d7cfcfaa60b7d1d1853d1">m_nMaxThreadCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">max count of thread <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2199b0cb3b53d071359731bcfa02904"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_nMaxRetiredPtrCount" ref="ad2199b0cb3b53d071359731bcfa02904" args="" -->
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad2199b0cb3b53d071359731bcfa02904">m_nMaxRetiredPtrCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">max count of retired ptr per thread <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d721652b6a1b637065f82327028b914"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_nScanType" ref="a7d721652b6a1b637065f82327028b914" args="" -->
<a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a7d721652b6a1b637065f82327028b914">m_nScanType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">scan type (see <a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> enum) <br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb10d9cadadffd5feb0c4eee087251c"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_pHZPManager" ref="a8fb10d9cadadffd5feb0c4eee087251c" args="" -->
static <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a8fb10d9cadadffd5feb0c4eee087251c">m_pHZPManager</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">GC instance pointer. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Hazard Pointer singleton. </p>
<p>Safe memory reclamation schema by Michael "Hazard Pointers"</p>
<dl class="user"><dt><b>Sources:</b></dt><dd><ul>
<li>[2002] Maged M.Michael "Safe memory reclamation for dynamic lock-freeobjects using atomic reads and writes" </li>
<li>[2003] Maged M.Michael "Hazard Pointers: Safe memory reclamation for lock-free objects" </li>
<li>[2004] Andrei Alexandrescy, Maged Michael "Lock-free Data Structures with Hazard Pointers" </li>
</ul>
</dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a31dda8e3842b9d9fe0e6188311c6ff03"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::GarbageCollector" ref="a31dda8e3842b9d9fe0e6188311c6ff03" args="(size_t nHazardPtrCount=0, size_t nMaxThreadCount=0, size_t nMaxRetiredPtrCount=0, scan_type nScanType=inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cds::gc::hzp::GarbageCollector::GarbageCollector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nHazardPtrCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nMaxThreadCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nMaxRetiredPtrCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a>&#160;</td>
          <td class="paramname"> <em>nScanType</em> = <code>inplace</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ctor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nHazardPtrCount</td><td>Hazard pointer count per thread </td></tr>
    <tr><td class="paramname">nMaxThreadCount</td><td>Max count of thread </td></tr>
    <tr><td class="paramname">nMaxRetiredPtrCount</td><td>Capacity of the array of retired objects </td></tr>
    <tr><td class="paramname">nScanType</td><td>Scan type (see <a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> enum) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aca8ba27f700ea8628550f0087a6394eb"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::checkHPCount" ref="aca8ba27f700ea8628550f0087a6394eb" args="(unsigned int nRequiredCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cds::gc::hzp::GarbageCollector::checkHPCount </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"> <em>nRequiredCount</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks that required hazard pointer count <code>nRequiredCount</code> is less or equal then max hazard pointer count. </p>
<p>If <code>nRequiredCount</code> &gt; <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a8533c264f525949b4fdd3acd07585483" title="Returns max Hazard Pointer count defined in construction time.">getHazardPointerCount()</a> then the exception HZPTooMany is thrown </p>

</div>
</div>
<a class="anchor" id="ad270c41d49a492134c6029a0733f567c"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::classic_scan" ref="ad270c41d49a492134c6029a0733f567c" args="(details::HPRec *pRec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::classic_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td>
          <td class="paramname"> <em>pRec</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Classic scan algorithm. </p>
<p>Classical scan algorithm as described in Michael's paper.</p>
<p>A scan includes four stages. The first stage involves scanning the array HP for non-null values. Whenever a non-null value is encountered, it is inserted in a local list of currently protected pointer. Only stage 1 accesses shared variables. The following stages operate only on private variables.</p>
<p>The second stage of a scan involves sorting local list of protected pointers to allow binary search in the third stage.</p>
<p>The third stage of a scan involves checking each reclaimed node against the pointers in local list of protected pointers. If the binary search yields no match, the node is freed. Otherwise, it cannot be deleted now and must kept in thread's list of reclaimed pointers.</p>
<p>The forth stage prepares new thread's private list of reclaimed pointers that could not be freed during the current scan, where they remain until the next scan.</p>
<p>This algorithm allocates memory for internal HP array.</p>
<p>This function is called internally by <a class="el" href="classcds_1_1gc_1_1hzp_1_1_thread_g_c.html" title="Thread&#39;s hazard pointer manager.">ThreadGC</a> object when upper bound of thread's list of reclaimed pointers is reached. </p>

</div>
</div>
<a class="anchor" id="a661b77fe748dc4c680fe7d93a10b8dae"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::Construct" ref="a661b77fe748dc4c680fe7d93a10b8dae" args="(size_t nHazardPtrCount=0, size_t nMaxThreadCount=0, size_t nMaxRetiredPtrCount=0, scan_type nScanType=inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void CDS_STDCALL cds::gc::hzp::GarbageCollector::Construct </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nHazardPtrCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nMaxThreadCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nMaxRetiredPtrCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a>&#160;</td>
          <td class="paramname"> <em>nScanType</em> = <code>inplace</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> singleton. </p>
<p>GC is the singleton. If GC instance is not exist then the function creates the instance. Otherwise it does nothing.</p>
<p>The Michael's HP reclamation schema depends of three parameters:</p>
<p><code>nHazardPtrCount</code> - HP pointer count per thread. Usually it is small number (2-4) depending from the data structure algorithms. By default, if <code>nHazardPtrCount</code> = 0, the function uses maximum of HP count for CDS library.</p>
<p><code>nMaxThreadCount</code> - max count of thread with using HP GC in your application. Default is 100.</p>
<p><code>nMaxRetiredPtrCount</code> - capacity of array of retired pointers for each thread. Must be greater than <code>nHazardPtrCount</code> * <code>nMaxThreadCount</code>. Default is 2 * <code>nHazardPtrCount</code> * <code>nMaxThreadCount</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nHazardPtrCount</td><td>Hazard pointer count per thread </td></tr>
    <tr><td class="paramname">nMaxThreadCount</td><td>Max count of thread in your application </td></tr>
    <tr><td class="paramname">nMaxRetiredPtrCount</td><td>Capacity of the array of retired objects for the thread </td></tr>
    <tr><td class="paramname">nScanType</td><td>Scan type (see <a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> enum) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a473247d2dcbe379c9c7e7a92b0dfec8a"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::DeleteHPRec" ref="a473247d2dcbe379c9c7e7a92b0dfec8a" args="(hplist_node *pNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::DeleteHPRec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> *&#160;</td>
          <td class="paramname"> <em>pNode</em>&#160;)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permanently deletes HPrecord <code>pNode</code>. </p>
<p>Caveat: for performance reason this function is defined as inline and cannot be called directly </p>

</div>
</div>
<a class="anchor" id="adbb722267c82e7bc69196d0346b3ad70"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::DeletePtr" ref="adbb722267c82e7bc69196d0346b3ad70" args="(details::retired_ptr &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::DeletePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1details_1_1retired__ptr.html">details::retired_ptr</a> &amp;&#160;</td>
          <td class="paramname"> <em>p</em>&#160;)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permanently deletes retired pointer <code>p</code>. </p>
<p>Caveat: for performance reason this function is defined as inline and cannot be called directly </p>

</div>
</div>
<a class="anchor" id="ac79c36f81454eb6002678dd3777b0a76"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::Destruct" ref="ac79c36f81454eb6002678dd3777b0a76" args="(bool bDetachAll=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void CDS_STDCALL cds::gc::hzp::GarbageCollector::Destruct </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>bDetachAll</em> = <code>false</code>&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroys global instance of <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a>. </p>
<p>The parameter <code>bDetachAll</code> should be used carefully: if its value is <code>true</code>, then the destroying GC automatically detaches all attached threads. This feature can be useful when you have no control over the thread termination, for example, when <code>libcds</code> is injected into existing external thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bDetachAll</td><td>Detach all threads </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e7056afcbc33c6cea9b32799f2e02d0"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::HelpScan" ref="a9e7056afcbc33c6cea9b32799f2e02d0" args="(details::HPRec *pThis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::HelpScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td>
          <td class="paramname"> <em>pThis</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper scan routine. </p>
<p>The function guarantees that every node that is eligible for reuse is eventually freed, barring thread failures. To do so, after executing Scan, a thread executes a HelpScan, where it checks every HP record. If an HP record is inactive, the thread moves all "lost" reclaimed pointers to thread's list of reclaimed pointers.</p>
<p>The function is called internally by Scan. </p>

</div>
</div>
<a class="anchor" id="adf7f45ee415a27a24f72433d4b33adfc"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::inplace_scan" ref="adf7f45ee415a27a24f72433d4b33adfc" args="(details::HPRec *pRec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::inplace_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td>
          <td class="paramname"> <em>pRec</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In-place scan algorithm. </p>
<p>Unlike the <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad270c41d49a492134c6029a0733f567c">classic_scan</a> algorithm, <code>inplace_scan</code> does not allocate any memory. All operations are performed in-place. </p>

</div>
</div>
<a class="anchor" id="a01bb09f35b1062c4decffce171c5620d"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::Scan" ref="a01bb09f35b1062c4decffce171c5620d" args="(details::HPRec *pRec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::Scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td>
          <td class="paramname"> <em>pRec</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main garbage collecting function. </p>
<p>This function is called internally by <a class="el" href="classcds_1_1gc_1_1hzp_1_1_thread_g_c.html" title="Thread&#39;s hazard pointer manager.">ThreadGC</a> object when upper bound of thread's list of reclaimed pointers is reached.</p>
<p>There are the following scan algorithm: </p>
<ul>
<li><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad270c41d49a492134c6029a0733f567c">classic_scan</a> allocates memory for internal use </li>
<li><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#adf7f45ee415a27a24f72433d4b33adfc">inplace_scan</a> does not allocate any memory</li>
</ul>
<p>Use <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ab0321a557cbd6a787bb5134d805da33b">setScanType</a> function to setup appropriate scan algorithm. </p>

</div>
</div>
<a class="anchor" id="ab0321a557cbd6a787bb5134d805da33b"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::setScanType" ref="ab0321a557cbd6a787bb5134d805da33b" args="(scan_type nScanType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::setScanType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a>&#160;</td>
          <td class="paramname"> <em>nScanType</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set current scan strategy. </p>
<p>Scan strategy changing is allowed on the fly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nScanType</td><td>new scan strategy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/gc/hzp/hzp.h</li>
</ul>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.8.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2011
			<br/>
			<i>Autogenerated Mon Mar 28 2011 21:10:38 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>
