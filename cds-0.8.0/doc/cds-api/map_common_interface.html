<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: Map common interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="main.html">CDS: Concurrent Data Structures library</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Map common interface </h1>  </div>
</div>
<div class="contents">
<p>The implementations of map are divided into two group. The first group is GC-based maps that supports item erasing. We calls that list as deletable map. The second group is based on <a class="el" href="structcds_1_1gc_1_1no__gc.html" title="Tag for empty GC schema for lock-free objects without deletion of items (persistent data structure)...">cds::gc::no_gc</a> that means the map is persistent and it does not support item erasing. The interface for persistent and deletable map is slightly different.</p>
<p>Preconditions for template parameters: </p>
<ul>
<li><code>VALUE</code> should be default-constructible</li>
</ul>
<p>Any map implementation in CDS library supports the following interface:</p>
<dl class="user"><dt><b>Stable interface</b></dt><dd></dd></dl>
<h2><a class="anchor" id="insert"></a>
insert</h2>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> insert (<span class="keyword">const</span> KEY &amp;key, <span class="keyword">const</span> VALUE &amp;val)
</pre></div><p> Insert new item (<em>key</em>, <em>val</em>) into the map </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key </td></tr>
    <tr><td class="paramname">val</td><td>a value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if insertion succeeded, <code>false</code> otherwise (i.e. the <em>key</em> already in the map)</dd></dl>
<h2><a class="anchor" id="insert"></a>
insert</h2>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> FUNC&gt;
    <span class="keywordtype">bool</span> insert (<span class="keyword">const</span> KEY &amp;key, <span class="keyword">const</span> T &amp;val, FUNC func )
</pre></div><p> Insert new item (<em>key</em>, <em>val</em>) into the map </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is a key </td></tr>
    <tr><td class="paramname">val</td><td>is a value </td></tr>
    <tr><td class="paramname">func</td><td>is uset-defined functor to initialize new item's value.</td></tr>
  </table>
  </dd>
</dl>
<p>The signature of functor <code>func</code> is: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>insert_functor {
        <span class="keywordtype">void</span> operator()( VALUE&amp; itemValue, <span class="keyword">const</span> T&amp; val ) ;
    };
</pre></div><p> where </p>
<ul>
<li><code>itemValue</code> is value of item inserted </li>
<li><code>val</code> is the value passed to <code>insert</code> member function The functor <code>func</code> must guarantee that during changing the value <code>itemValue</code> no other changes or reads could be made on this map item by concurrent threads.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if insertion succeeded, <code>false</code> otherwise (i.e. the <em>key</em> already in the map)</dd></dl>
<h2><a class="anchor" id="ensure"></a>
ensure</h2>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> FUNC&gt;
    std::pair&lt; bool, bool &gt; ensure (<span class="keyword">const</span> KEY &amp;key, <span class="keyword">const</span> T &amp;val, FUNC func)
</pre></div><p> Ensures that the <code>key</code> exists in map, changes data of existing item to <code>val</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key </td></tr>
    <tr><td class="paramname">val</td><td>the value </td></tr>
    <tr><td class="paramname">func</td><td>the functor making change of item's value</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If <code>key</code> exists in the map then the function changes the value of the item pointed by <code>key</code> to <code>val</code>. Changing is performed by calling the functor <code>func</code> with signature: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">struct </span>ensure_functor {
            <span class="keywordtype">void</span> operator()( VALUE&amp; itemValue, <span class="keyword">const</span> T&amp; val, <span class="keywordtype">bool</span> bNew ) ;
        };
</pre></div><p> where parameters are: </p>
<ul>
<li><code>itemValue</code> is the reference to the map's item pointed by key <code>key</code> </li>
<li><code>val</code> is the value passed to <code>ensure</code> member function </li>
<li><code>bNew</code> equals <code>true</code> if a new item has been added for <code>key</code>, and <code>false</code> if <code>key</code> is found. The functor <code>func</code> must guarantee that during changing the value <code>itemValue</code> no other changes or reads could be made on this map item by concurrent threads.</li>
</ul>
<p>If <code>key</code> is not in the map then <code>ensure</code> add it like <code>insert</code>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>std::pair&lt;bool, bool&gt;</code> where <code>first</code> is <code>true</code> if operation is successfull, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with <em>key</em> already in the map.</dd></dl>
<h2><a class="anchor" id="emplace"></a>
emplace</h2>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> FUNC&gt;
    <span class="keywordtype">bool</span> emplace( <span class="keyword">const</span> KEY&amp; key, <span class="keyword">const</span> T&amp; val, FUNC func )
</pre></div><p> Emplaces the value of key <code>key</code> with new value <code>val</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key to find </td></tr>
    <tr><td class="paramname">val</td><td>new value </td></tr>
    <tr><td class="paramname">func</td><td>functor to change the item's value of key <code>key</code> </td></tr>
  </table>
  </dd>
</dl>
<p>The operation changes the value (or a part of its) of key <code>key</code> to new <code>val</code>. The functor <code>func</code> has the purpose like <code>func</code> argument of <a class="el" href="ordered_list_common_interface.html#ensure">ensure</a> member function. The signature of <code>func</code> is </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">struct </span>emplace_functor {
            <span class="keywordtype">void</span> operator()( VALUE&amp; itemValue, <span class="keyword">const</span> T&amp; val ) ;
        };
</pre></div><p> The first argument <code>itemValue</code> of the functor <code>func</code> is the reference to the map's item pointed by <code>key</code>. The second argument <code>val</code> is the value passed to <code>emplace</code> member function. <code>func</code> must guarantee that during changing key's value no other changes could be made on this map's item by concurrent thread. The map only guarantees that the item found by key cannot be deleted while <code>func</code> worked.</p>
<p>If <code>key</code> is not found in the map, then <code>func</code> is not called.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns <code>true</code> if the <code>key</code> exists in the map, <code>false</code> otherwise</dd></dl>
<h2><a class="anchor" id="erase"></a>
erase</h2>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> erase (<span class="keyword">const</span> KEY &amp;key)
</pre></div><p> Erases a key <em>key</em> from the map </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key for deleting </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if key <em>key</em> found and deleted from the map, <code>false</code> if the <em>key</em> is not found in the map </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The <code>erase</code> method is applicable for non-persistent implementation only. Persistent implementations (based on <a class="el" href="structcds_1_1gc_1_1no__gc.html" title="Tag for empty GC schema for lock-free objects without deletion of items (persistent data structure)...">cds::gc::no_gc</a>) don't support <code>erase</code>.</dd></dl>
<h2><a class="anchor" id="erase"></a>
erase</h2>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> FUNC&gt;
    <span class="keywordtype">bool</span> erase( <span class="keyword">const</span> key_type&amp; key, T&amp; dest, FUNC func ) ;
</pre></div><p> This function is designed to remove a list item. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key for deleting </td></tr>
    <tr><td class="paramname">dest</td><td>argument for <code>func</code> </td></tr>
    <tr><td class="paramname">func</td><td>the functor called before deleting item found. Before removing the item found by <code>key</code>, the functor <code>func</code> is called. The functor has the following signature: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">struct </span>erase_functor {
            <span class="keywordtype">void</span> operator()( T&amp; dest, VALUE&amp; itemValue ) ;
        };
</pre></div><p> where <code>itemValue</code> is the item to erase. The functor may change <code>itemValue</code>; for example, it may produce a preliminary cleaning of <code>itemValue</code>, or it may save some data from <code>itemValue</code> to <code>dest</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The <code>erase</code> method is applicable for non-persistent implementation only. Persistent implementations (based on <a class="el" href="structcds_1_1gc_1_1no__gc.html" title="Tag for empty GC schema for lock-free objects without deletion of items (persistent data structure)...">cds::gc::no_gc</a>) don't support <code>erase</code>.</dd></dl>
<h2><a class="anchor" id="find"></a>
find</h2>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> find (<span class="keyword">const</span> KEY &amp;key)
</pre></div><p> Find a key <code>key</code> in the map </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key searching </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>key</em> found, <code>false</code> otherwise</dd></dl>
<h2><a class="anchor" id="find"></a>
find</h2>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> FUNC&gt;
    <span class="keywordtype">bool</span> find (<span class="keyword">const</span> KEY &amp;key, T &amp;data, FUNC func)
</pre></div><p> Find key in the map. If <code>key</code> is found returns its data in <em>data</em> parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key </td></tr>
    <tr><td class="paramname">val</td><td>a value found </td></tr>
    <tr><td class="paramname">func</td><td>the user-defined functor to return item's value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>key</em> found, <code>false</code> otherwise</dd></dl>
<p>If <code>key</code> found the functor <code>func</code> is called with parameters: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">struct </span>find_functor {
            <span class="keywordtype">void</span> operator ()( T&amp; data, <span class="keyword">const</span> VALUE&amp; itemValue )
        };
</pre></div><p> where <code>itemValue</code> is the item found by <code>key</code>. The functor copies the item's value <code>itemValue</code> or its part to <code>data</code>. The map guarantees only that the item found cannot be deleted while <code>func</code> works. The functor <code>func</code> should take into account that concurrent threads may change the item value.</p>
<h2><a class="anchor" id="empty"></a>
empty</h2>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> empty () const
</pre></div><p> Checks if the map is empty. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the map is empty, <code>false</code> otherwise</dd></dl>
<h2><a class="anchor" id="clear"></a>
clear</h2>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> clear ()
</pre></div><p> Clears the map. For many map implementation this function is not thread safe.</p>
<h2><a class="anchor" id="size"></a>
size</h2>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">size_t</span> size() const
</pre></div><p> Returns item count. Note that <code>size()==0</code> is not equal to <code>empty()==true</code> because of lock-free nature of the algorithms implemented in CDS library. The value returned is approximate estimation of map's item count. To check whether the map is empty you should use <code>empty()</code> method. </p>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.8.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2011
			<br/>
			<i>Autogenerated Mon Mar 28 2011 21:10:36 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>
